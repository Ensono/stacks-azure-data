# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

# Sample YAML file to validate and export an ARM template into a build artifact
# Requires a package.json file located in the target repository

name: "$(Build.SourceBranchName)-init"

trigger:
- none

# pr:
#   - main

# trigger:
#   branches:
   
#     include:
#       - 'main'
#   paths:
#     include:
#       - data_quality/config/*
#       - data_quality/data-quality-config-pipeline.yml


variables:
  - template: ../de_build/job-pipeline-vars.yml
  - template: ../build/version-data-vars.yml
#  - template: de_build/adf/air-data-testing-vars.yml
  # - name: job  #update job name
  #   value: 'Generate_Ingest_Query'
  - name: self_repo_blob_config
    value: "$(self_repo_dir)/data_quality/config"
  - name: blob_config_destination
    value: config

pool:
  name: $(agentpool_name)

stages:
- stage: Release
  variables:
      - group: amido-stacks-infra-credentials-nonprod
      # - name: version_number
      #   value: "$(version_major).$(version_minor).$(version_revision)"
  jobs:
      - job: CreateGitHubRelease
        pool:
          name: $(agentpool_name)
        steps:
          # Check out the repo so that it can be tagged
          - checkout: self
            persistCredentials: true
            #ref: 'refs/heads/main'

          - script: |
              lastTag=$(git tag --sort=-creatordate | head -n 1)
              if [[ -z $lastTag ]]; then
                major=$(version_major)
                minor=$(version_minor)
                revision=$(version_revision)
                echo "Last Tag: NOT Present"
              else
                IFS='.' read -ra versionParts <<< "${lastTag#v}"
                major="${versionParts[0]}"
                minor="${versionParts[1]}"
                lastrevision="${versionParts[2]}"
                revision=$((lastrevision + 1))
                echo "Last Tag: $lastTag"
              fi
              newVersion="${major}.${minor}.${revision}"
              echo "New Version: $newVersion"
              echo "##vso[task.setvariable variable=major]$major"
              echo "##vso[task.setvariable variable=minor]$minor"
              echo "##vso[task.setvariable variable=revision]$revision"
              echo "##vso[task.setvariable variable=newVersion]$newVersion"
            displayName: Determine New Version

          - script: |
              latestTag=$(git describe --tags --abbrev=0)
              echo "latestTag: $latestTag"
            displayName: Determine latest Version

          - script: |
              commit=$(Build.SourceVersion)
              tag=$(git tag --contains $commit)
              if [ -z "$tag" ]; then
                echo "Tag does not exist for the commit"
                git config user.name "BuildService"
                git config user.email "builder@${COMPANY}.com"
                echo "Creating tag v${newVersion}..."
                git tag -a "v${newVersion}" -m "Release created by Azure DevOps"
                git push origin "v${newVersion}"
              else
                echo "Tag '$tag' exists for the commit.Skipping tag creation"
              fi
            displayName: Check Tag

          # - script: |
          #     echo " 1---->v$(newVersion)"
          #     echo " 1---->v$(major)"
          #     echo "2--->v${{ variables.newVersion }}"
          #   displayName: Create New Tag

          # - task: Bash@3
          #   displayName: Tag Code
          #   inputs:
          #     targetType: "inline"
          #     script: |
          #       echo " 1---->v$(newVersion)"
          #       echo "2--->v${{ variables.newVersion }}"

         # Create a new tag with the incremented version
          # - script: |
          #     git config user.name "BuildService"
          #     git config user.email "builder@${COMPANY}.com"
          #     git tag -a v$(newVersion) -m "Release created by Azure DevOps"
          #     git push origin v$(newVersion)
          #   displayName: Create New Tag



          - task: Bash@3
            displayName: Tag Code
            inputs:
              targetType: "inline"
              script: |
                commit=$(Build.SourceVersion)
                if git rev-parse -q --verify $commit; then
                  echo "Tag exists for the commit.Skipping tag creation"
                else
                  git config user.name "BuildService"
                  git config user.email "builder@${COMPANY}.com"
                  echo "Creating tag v${newVersion}..."
                  git tag -a "v${newVersion}" -m "Release created by Azure DevOps"
                  git push origin "v${newVersion}"
                fi
            env:
              COMPANY: $(company)
              newVersion: $(newVersion)

          # #           # Create a GitHub release with these packages
          # - task: GitHubRelease@1
          #   displayName: Create GitHub Release
          #   inputs:
          #     gitHubConnection: $(github_release_service_connection)
          #     repositoryName: $(github_org)/$(self_repo)
          #     tag: v${newVersion}
          #     releaseNotesSource: 'inline'
          #     releaseNotesInline: "$(major).$(minor).$(revision)"
          #     tagSource: 'gitTag'
          #     changeLogCompareToRelease: 'lastFullRelease'
          #     changeLogType: 'commitBased'
