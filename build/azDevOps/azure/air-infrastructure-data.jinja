name: "$(Build.SourceBranchName)-init"

pr:
  branches:
    include:
      - "main"
  paths:
    include:
      - build/azDevOps/*
      - build/taskctl/*
      - deploy/azure/infra/*

trigger:
  branches:
    include:
      - "main"
  paths:
    include:
      - build/azDevOps/*
      - build/taskctl/*
      - deploy/azure/infra/*
variables:
  - template: air-infrastructure-data-vars.yml

stages:
  - stage: Build
    variables:
      - group: stacks-credentials-nonprod-kv

    jobs:
      - job: Validate
        pool:
          # vmImage: $(pool_vm_image)
          name: $(agentpool_name)

        steps:
          - task: Bash@3
            displayName: "Clean Workspace"
            inputs:
              targetType: "inline"
              script: |
                echo "Cleaning workspace..."
                sudo rm -rf $(Build.SourcesDirectory)/*
          - template: ../templates/air-infrastructure-data-setup.yml
            parameters:
              TaskctlVersion: {% raw %}${{ variables.TaskctlVersion }}{% endraw %}

          - task: Bash@3
            displayName: "TaskCTL: Setup"
            inputs:
              targetType: inline
              script: taskctl setup
            env:
              DOCKER_IMAGE_TAG: $(version_number)

          - task: Bash@3
            displayName: "TaskCTL: Lint"
            inputs:
              targetType: inline
              script: taskctl lint
            env:
              # Dotnet Build
              SELF_REPO_SRC: $(self_repo_src)
              CLOUD_PROVIDER: "$(cloud_provider)"
              ARM_TENANT_ID: "$(azure-tenant-id)"
              ARM_SUBSCRIPTION_ID: "$(azure-subscription-id)"
              ARM_CLIENT_ID: "$(azure-client-id)"
              ARM_CLIENT_SECRET: "$(azure-client-secret)"

  {%- for environment in environments %}

    - stage: {{ environment.stage_name }}
      dependsOn: 
        {%- for depends_on in environment.depends_on %}
        - {{ depends_on }}
        {%- endfor %}
      condition: and(succeeded(), {% if environment.trigger_from_main_branch -%}eq{% else -%}ne{% endif %}(variables['Build.SourceBranch'], 'refs/heads/main'))
      variables:
        - group: stacks-credentials-{{ environment.name }}-kv
        - group: amido-stacks-euw-de-{{ environment.name }}-network
        - group: amido-stacks-de-pipeline-{{ environment.name }}
        - name: Environment.ShortName
          value: {% if environment.short_name -%}{{ environment.short_name }}{% else -%}{{ environment.name }}{% endif %}
        # Available in Terraform Output, but not yet enabled to export as pipeline vars
        - name: dns_base_domain
          value: {{ environment.name }}.amidostacks.com
        - name: core_environment
          value: {{ environment.name }}
      jobs:
        - deployment: Infra{{ environment.stage_name }}
          pool: #"amido-stacks-core-data-agent-pool"
            # vmImage: $(pool_vm_image)
            name: $(agentpool_name)
          environment: {% raw %}${{ variables.domain }}{% endraw %}-{{ environment.name }}
          strategy:
            runOnce:
              deploy:
                steps:
                  - task: Bash@3
                    displayName: "Clean Workspace"
                    inputs:
                      targetType: "inline"
                      script: |
                        echo "Cleaning workspace..."
                        sudo rm -rf $(Build.SourcesDirectory)/*
                  - template: ../templates/air-infrastructure-data-setup.yml
                    parameters:
                      TaskctlVersion: {% raw %}${{ variables.TaskctlVersion }}{% endraw %}
                  - bash: |
                      ip=$(curl https://api.ipify.org/?format=json | jq -r .ip)
                      echo "$ip"
                      echo "##vso[task.setvariable variable=build_agent_ip;]$ip"
                    displayName: "Get Build Agent IP"
                  - task: Bash@3
                    displayName: "Taskctl: Infrastructure"
                    inputs:
                      targetType: inline
                      script: taskctl infrastructure
                      informationPreference: continue
                    env:
                      ENV_NAME: $(Environment.ShortName)
                      # Azure Authentication
                      CLOUD_PROVIDER: "$(cloud_provider)"
                      ARM_CLIENT_ID: $(azure-client-id)
                      ARM_CLIENT_SECRET: $(azure-client-secret)
                      ARM_SUBSCRIPTION_ID: $(azure-subscription-id)
                      ARM_TENANT_ID: $(azure-tenant-id)
                      # Terraform Backend Configuration
                      TF_STATE_CONTAINER: $(tf_state_container)
                      TF_STATE_KEY: $(tf_state_key)
                      TS_STATE_RG: $(tf_state_rg)
                      TF_STATE_STORAGE: $(tf_state_storage)
                      TF_BACKEND_ARGS: "key=$(tf_state_key),storage_account_name=$(TF_STATE_STORAGE),resource_group_name=$(TF_STATE_RG),container_name=$(TF_STATE_CONTAINER),subscription_id=$(azure-subscription-id),tenant_id=$(azure-tenant-id),client_id=$(azure-client-id),client_secret= $(azure-client-secret)"
                      # Deployment Specific Configuration
                      TF_VAR_core_environment: $(core_environment)
                      TF_VAR_name_component: $(component)
                      TF_VAR_resource_group_location: $(region)
                      TF_VAR_create_cdn_endpoint: false
                      TF_VAR_create_dns_record: {% if environment.production_equivalent -%} true {% else -%} false {% endif %}
                      TF_VAR_name_company: $(company)
                      TF_VAR_name_project: $(project)
                      TF_VAR_name_domain: $(domain)
                      TF_VAR_stage: $(Environment.ShortName)
                      TF_VAR_git_integration: $(git_integration{% if environment.production_equivalent -%}_prod{% else -%}{% endif %})
                      TF_VAR_administrator_login: $(sql_admin_login)
                      TF_VAR_build_agent_ip: $(build_agent_ip)
                      TF_VAR_subnet_name: $(pe_subnet_name)
                      TF_VAR_vnet_name: $(pe_vnet_name)
                      TF_VAR_vnet_resource_group_name: $(pe_resource_group_name)
                      TF_VAR_public_subnet_name: $(databricks_public_subnet_name)
                      TF_VAR_private_subnet_name: $(databricks_private_subnet_name)
                      TF_VAR_pe_subnet_name: $(pe_subnet_name)
                      TF_VAR_public_subnet_prefix: $(public_subnet_prefix)
                      TF_VAR_private_subnet_prefix: $(private_subnet_prefix)
                      TF_VAR_pe_subnet_prefix: $(pe_subnet_prefix)
                      TF_VAR_link_dns_{% if environment.production_equivalent -%}prod{% else -%}dev{% endif %}_spoke_network: true
                      TF_VAR_public_network_access_enabled: {% if environment.production_equivalent -%} false {% else -%} true {% endif %}
                      TF_VAR_browser_authentication_enabled: {% if environment.production_equivalent -%} true {% else -%} false {% endif %}
                      TF_VAR_azure_client_secret: $(azure-client-secret)
  {%- endfor %}
  {% if release.create -%} 
  - stage: Release
    dependsOn:
      {%- for depends_on in release.depends_on %}
      - {{ depends_on }}
      {%- endfor %}
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['create_release'], 'true'))
    jobs:
      - job: CreateGitHubRelease
        pool:
          # vmImage: $(pool_vm_image)
          name: $(agentpool_name)
        steps:
          - task: Bash@3
            displayName: "Clean Workspace"
            inputs:
              targetType: "inline"
              script: |
                echo "Cleaning workspace..."
                sudo rm -rf $(Build.SourcesDirectory)/*
          # Check out the repo so that it can be tagged
          - checkout: self
            persistCredentials: true

          - script: |
              lastTag=$(git tag --sort=-creatordate | head -n 1)
              if [[ -z $lastTag ]]; then
                major=$(version_major)
                minor=$(version_minor)
                revision=$(version_revision)
                echo "Last Tag: NOT Present"
              else
                IFS='.' read -ra versionParts <<< "${lastTag#v}"
                major="${versionParts[0]}"
                minor="${versionParts[1]}"
                lastrevision="${versionParts[2]}"
                revision=$((lastrevision + 1))
                echo "Last Tag: $lastTag"
              fi
              newVersion="${major}.${minor}.${revision}"
              echo "New Version: $newVersion"
              echo "##vso[task.setvariable variable=major]$major"
              echo "##vso[task.setvariable variable=minor]$minor"
              echo "##vso[task.setvariable variable=revision]$revision"
              echo "##vso[task.setvariable variable=newVersion]$newVersion"
            displayName: Determine New Version

          - task: Bash@3
            displayName: Tag Code
            inputs:
              targetType: "inline"
              script: |
                commit=$(Build.SourceVersion)
                tag=$(git tag --contains $commit)
                if [ -z "$tag" ]; then
                  echo "Tag does not exist for the commit"
                  git config user.name "BuildService"
                  git config user.email "builder@${COMPANY}.com"
                  echo "Creating tag v${newVersion}..."
                  git tag -a "v${newVersion}" -m "Release created by Azure DevOps"
                  git push origin "v${newVersion}"
                  echo "##vso[task.setvariable variable=ShouldCreateRelease]True"
                else
                  echo "Tag '$tag' already exists for the commit.Skipping tag creation"
                  echo "##vso[task.setvariable variable=ShouldCreateRelease]false"
                fi
            env:
              COMPANY: $(company)
              newVersion: $(newVersion)

          # #           # Create a GitHub release with these packages
          - task: GitHubRelease@1
            displayName: Create GitHub Release
            inputs:
              gitHubConnection: $(github_release_service_connection)
              repositoryName: $(github_org)/$(self_repo)
              tag: v${newVersion}
              releaseNotesSource: "inline"
              releaseNotesInline: "$(major).$(minor).$(revision)"
              tagSource: "gitTag"
              changeLogCompareToRelease: "lastFullRelease"
              changeLogType: "commitBased"
            condition: eq(variables['ShouldCreateRelease'], 'true')
  {% endif %}