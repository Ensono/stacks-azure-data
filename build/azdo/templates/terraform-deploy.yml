# Reusable template for Terraform deployment steps
parameters:
  - name: stage_name
    type: string
  - name: tf_state_key
    type: string
  - name: download_artifact
    type: string
    default: ""
  - name: artifact_file
    type: string
    default: ""
  - name: destroy
    type: boolean
    default: false
  - name: deploy
    type: boolean
    default: true

steps:
  - task: Bash@3
    displayName: "Cleanup: Remove .terraform directories"
    inputs:
      targetType: inline
      script: |
        echo "Cleaning workspace..."
        sudo rm -rf $(Build.SourcesDirectory)/deploy/terraform/*/.terraform
    continueOnError: true  # Safe to continue if cleanup fails (directories may not exist on first run)

  - checkout: self
    clean: true

  - ${{ if ne(parameters.download_artifact, '') }}:
      - task: DownloadPipelineArtifact@2
        displayName: "Download ${{ parameters.download_artifact }} artifacts"
        inputs:
          buildType: current
          artifactName: ${{ parameters.download_artifact }}
          targetPath: $(Agent.TempDirectory)/${{ parameters.download_artifact }}

  - template: install-eirctl.yml
    parameters:
      EirctlVersion: $(EirctlVersion)

  - task: Bash@3
    displayName: "Eirctl: Initialise Terraform"
    inputs:
      targetType: inline
      script: |
        export USER_ID=`id -u`
        export USER_GROUP_ID=`id -g`
        eirctl -d infra:init
    env:
      ARM_CLIENT_ID: $(ARM_CLIENT_ID)
      ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
      ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
      ARM_TENANT_ID: $(ARM_TENANT_ID)
      TF_BACKEND_INIT: "key=${{ parameters.tf_state_key }},storage_account_name=$(tf_state_storage),resource_group_name=$(tf_state_rg),container_name=$(tf_state_container)"

  - ${{ if and(ne(parameters.download_artifact, ''), ne(parameters.artifact_file, '')) }}:
      - task: CopyFiles@2
        displayName: "Copy Terraform Variables file"
        inputs:
          SourceFolder: $(Agent.TempDirectory)/${{ parameters.download_artifact }}/
          Contents: "${{ parameters.artifact_file }}"
          TargetFolder: $(Build.SourcesDirectory)/deploy/terraform/${{ parameters.stage_name }}

  - ${{ if eq(parameters.destroy, true) }}:
      - task: Bash@3
        displayName: "Eirctl: [DESTROY] Plan ${{ parameters.stage_name }}"
        inputs:
          targetType: inline
          script: |
            eirctl infra:destroy:plan
        env:
          ARM_CLIENT_ID: $(ARM_CLIENT_ID)
          ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
          ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(ARM_TENANT_ID)
          TF_VAR_name_company: $(company)
          TF_VAR_name_project: $(project)
          TF_VAR_ado_org_url: $(ado_org_url)
          TF_VAR_ado_project_id: $(ado_project_id)

      - task: Bash@3
        displayName: "Eirctl: [DESTROY] Apply ${{ parameters.stage_name }}"
        inputs:
          targetType: inline
          script: |
            eirctl infra:destroy:apply
        env:
          ARM_CLIENT_ID: $(ARM_CLIENT_ID)
          ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
          ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(ARM_TENANT_ID)

  - ${{ if eq(parameters.deploy, true) }}:
      - task: Bash@3
        displayName: "Get Hosted Agent Public IP"
        inputs:
          targetType: inline
          script: |
            AGENT_IP=$(curl -s https://api.ipify.org)
            echo "Hosted Agent Public IP: $AGENT_IP"
            echo "##vso[task.setvariable variable=AGENT_PUBLIC_IP]$AGENT_IP"
        continueOnError: false

      - task: Bash@3
        displayName: "Eirctl: Plan ${{ parameters.stage_name }}"
        inputs:
          targetType: inline
          script: |
            eirctl -d infra:plan
        env:
          ARM_CLIENT_ID: $(ARM_CLIENT_ID)
          ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
          ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(ARM_TENANT_ID)
          TF_VAR_name_company: $(company)
          TF_VAR_name_project: $(project)
          TF_VAR_ado_org_url: $(ado_org_url)
          TF_VAR_ado_project_id: $(ado_project_id)

      - task: Bash@3
        displayName: "Add Hosted Agent IP to KeyVault ACL"
        inputs:
          targetType: inline
          script: |
            # Login to Azure using service principal
            az login --service-principal \
              --username "$ARM_CLIENT_ID" \
              --password "$ARM_CLIENT_SECRET" \
              --tenant "$ARM_TENANT_ID" \
              --output none

            az account set --subscription \"$ARM_SUBSCRIPTION_ID\"

            # Find KeyVault by resource group
            # Resource group name follows: {company}-{project}-{location}-{component}-{environment}
            RG_NAME=\"$(company)-$(project)-$(region)-$(domain)-$(env_name)\"

            KV_NAME=$(az keyvault list \
              --resource-group \"$RG_NAME\" \
              --query \"[0].name\" \
              -o tsv 2>/dev/null || echo \"\")

            if [ -z \"$KV_NAME\" ]; then
              echo \"KeyVault not found in resource group $RG_NAME, skipping ACL configuration\"
              echo \"This is expected on first deployment\"
              echo \"##vso[task.setvariable variable=KV_ACL_ADDED]false\"
            else
              echo "Found KeyVault: $KV_NAME"
              echo "Adding agent IP $(AGENT_PUBLIC_IP) to KeyVault network ACL"

              # Add the agent IP to the KeyVault firewall
              az keyvault network-rule add \
                --name "$KV_NAME" \
                --ip-address "$(AGENT_PUBLIC_IP)" \
                --output none

              echo "##vso[task.setvariable variable=KV_NAME]$KV_NAME"
              echo "##vso[task.setvariable variable=KV_ACL_ADDED]true"

              # Wait for the rule to propagate
              echo "Waiting 30 seconds for network rule propagation..."
              sleep 30
            fi
        env:
          ARM_CLIENT_ID: $(ARM_CLIENT_ID)
          ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
          ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(ARM_TENANT_ID)
        continueOnError: false

      - task: Bash@3
        displayName: "Eirctl: Apply ${{ parameters.stage_name }}"
        inputs:
          targetType: inline
          script: |
            export USER_ID=`id -u`
            export USER_GROUP_ID=`id -g`
            eirctl infra:apply
        env:
          ARM_CLIENT_ID: $(ARM_CLIENT_ID)
          ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
          ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(ARM_TENANT_ID)

      - task: Bash@3
        displayName: "Remove Hosted Agent IP from KeyVault ACL"
        condition: and(always(), eq(variables['KV_ACL_ADDED'], 'true'))
        inputs:
          targetType: inline
          script: |
            # Login to Azure using service principal
            az login --service-principal \
              --username "$ARM_CLIENT_ID" \
              --password "$ARM_CLIENT_SECRET" \
              --tenant "$ARM_TENANT_ID" \
              --output none

            az account set --subscription "$ARM_SUBSCRIPTION_ID"

            echo "Removing agent IP $(AGENT_PUBLIC_IP) from KeyVault $(KV_NAME) network ACL"

            az keyvault network-rule remove \
              --name "$(KV_NAME)" \
              --ip-address "$(AGENT_PUBLIC_IP)" \
              --output none

            echo "KeyVault ACL cleanup completed"
        env:
          ARM_CLIENT_ID: $(ARM_CLIENT_ID)
          ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
          ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(ARM_TENANT_ID)
        continueOnError: true

      - task: Bash@3
        displayName: "Ensure ${{ parameters.stage_name }} artifact directory exists"
        inputs:
          targetType: inline
          script: |
            mkdir -p $(Build.ArtifactStagingDirectory)/${{ parameters.stage_name }}
            echo "Staging directory prepared: $(Build.ArtifactStagingDirectory)/${{ parameters.stage_name }}"

      - task: CopyFiles@2
        displayName: Copy stage output files to staging area
        inputs:
          flattenFolders: true
          contents: $(Build.SourcesDirectory)/outputs/terraform/*${{ parameters.stage_name }}*
          targetFolder: $(Build.ArtifactStagingDirectory)/${{ parameters.stage_name }}

      - task: PublishPipelineArtifact@1
        displayName: Upload Generated Files
        inputs:
          targetPath: $(Build.ArtifactStagingDirectory)/${{ parameters.stage_name }}
          artifact: ${{ parameters.stage_name }}
