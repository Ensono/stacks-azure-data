# Reusable template for Terraform deployment steps
parameters:
  - name: stage_name
    type: string
  - name: tf_backend_key
    type: string
  - name: download_artifact
    type: string
    default: ""
  - name: artifact_file
    type: string
    default: ""
  - name: destroy
    type: boolean
    default: false
  - name: deploy
    type: boolean
    default: true

steps:
  - task: Bash@3
    displayName: "Cleanup: Remove .terraform directories"
    inputs:
      targetType: inline
      script: |
        echo "Cleaning workspace..."
        sudo rm -rf $(Build.SourcesDirectory)/deploy/terraform/*/.terraform
    continueOnError: true

  - checkout: self
    clean: true

  - ${{ if ne(parameters.download_artifact, '') }}:
      - task: DownloadPipelineArtifact@2
        displayName: "Download ${{ parameters.download_artifact }} artifacts"
        inputs:
          buildType: current
          artifactName: ${{ parameters.download_artifact }}
          targetPath: $(Agent.TempDirectory)/${{ parameters.download_artifact }}
        continueOnError: true

  - template: install-eirctl.yml
    parameters:
      EirctlVersion: $(EirctlVersion)

  - task: Cache@2
    displayName: "Cache: Docker image"
    inputs:
      key: 'docker | "$(Agent.OS)" | "ensono/eir-infrastructure" | "$(EirctlVersion)"'
      path: $(Pipeline.Workspace)/.docker-cache
      cacheHitVar: DOCKER_CACHE_RESTORED

  - task: Bash@3
    displayName: "Docker: Restore cached image"
    condition: eq(variables.DOCKER_CACHE_RESTORED, 'true')
    inputs:
      targetType: inline
      script: |
        if [ -f $(Pipeline.Workspace)/.docker-cache/eir-infrastructure.tar ]; then
          echo "Loading cached Docker image..."
          docker load -i $(Pipeline.Workspace)/.docker-cache/eir-infrastructure.tar
          # Retag common references used by eirctl to maximize cache hit
          for SRC in \
            ensono/eir-infrastructure:latest \
            ghcr.io/ensono/eir-infrastructure:latest; do
            if docker image inspect "$SRC" >/dev/null 2>&1; then
              docker tag "$SRC" ensono/eir-infrastructure:$(EirctlVersion) || true
              docker tag "$SRC" ghcr.io/ensono/eir-infrastructure:$(EirctlVersion) || true
            fi
          done
          # Ensure latest tags exist too
          for SRC in \
            ensono/eir-infrastructure:$(EirctlVersion) \
            ghcr.io/ensono/eir-infrastructure:$(EirctlVersion); do
            if docker image inspect "$SRC" >/dev/null 2>&1; then
              docker tag "$SRC" ensono/eir-infrastructure:latest || true
              docker tag "$SRC" ghcr.io/ensono/eir-infrastructure:latest || true
            fi
          done
          echo "Cached image loaded successfully"
        fi

  - task: Bash@3
    displayName: "Eirctl: Initialise Terraform"
    inputs:
      targetType: inline
      script: |
        export USER_ID=`id -u`
        export USER_GROUP_ID=`id -g`
        eirctl -d infra:init
    env:
      ARM_CLIENT_ID: $(ARM_CLIENT_ID)
      ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
      ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
      ARM_TENANT_ID: $(ARM_TENANT_ID)
      TF_BACKEND_INIT: "key=${{ parameters.tf_backend_key }},storage_account_name=$(tf_state_storage),resource_group_name=$(tf_state_rg),container_name=$(tf_state_container)"

  - ${{ if and(ne(parameters.download_artifact, ''), ne(parameters.artifact_file, '')) }}:
      - task: CopyFiles@2
        displayName: "Copy Terraform Variables file"
        inputs:
          SourceFolder: $(Agent.TempDirectory)/${{ parameters.download_artifact }}/
          Contents: "${{ parameters.artifact_file }}"
          TargetFolder: $(Build.SourcesDirectory)/deploy/terraform/${{ parameters.stage_name }}
        continueOnError: true

  - ${{ if eq(parameters.destroy, true) }}:
      - task: Bash@3
        displayName: "Prepare: Extract Databricks destroy variables"
        inputs:
          targetType: inline
          script: |
            set -euo pipefail

            # Only prepare for Databricks stage
            if [ "${{ parameters.stage_name }}" != "databricks" ]; then
              echo "Stage ${{ parameters.stage_name }} does not require prepare step"
              exit 0
            fi

            cd $(Build.SourcesDirectory)/deploy/terraform/databricks

            # If a .auto.tfvars already exists (from artifact), skip
            if ls *.auto.tfvars >/dev/null 2>&1; then
              echo "Existing tfvars found; skipping prepare"
              exit 0
            fi

            echo "No tfvars detected; extracting variables from Infra state and Azure APIs..."

            # Ensure Terraform CLI available for reading infra outputs
            if ! command -v terraform >/dev/null 2>&1; then
              echo "Installing Terraform CLI..."
              curl -fsSL -o /tmp/terraform.zip https://releases.hashicorp.com/terraform/1.6.6/terraform_1.6.6_linux_amd64.zip
              sudo unzip -o /tmp/terraform.zip -d /usr/local/bin
              rm -f /tmp/terraform.zip
              terraform version || true
            fi

            # Read Infra outputs
            cd $(Build.SourcesDirectory)/deploy/terraform/infra
            terraform init -input=false -reconfigure \
              -backend-config="key=$(company)-$(project)-$(domain)-infra" \
              -backend-config="storage_account_name=$(tf_state_storage)" \
              -backend-config="resource_group_name=$(tf_state_rg)" \
              -backend-config="container_name=$(tf_state_container)"

            # Output names from infra: adb_databricks_id, adb_host_url, kv_name, resource_group_name
            ADB_ID=$(terraform output -raw adb_databricks_id 2>/dev/null || echo "")
            ADB_HOST=$(terraform output -raw adb_host_url 2>/dev/null || echo "")
            KV_NAME=$(terraform output -raw kv_name 2>/dev/null || echo "")
            RG_NAME=$(terraform output -raw resource_group_name 2>/dev/null || echo "")

            # Return to Databricks dir
            cd $(Build.SourcesDirectory)/deploy/terraform/databricks

            # Resolve Key Vault id and uri via Azure CLI if kv_name present
            KV_ID=""
            KV_URI=""
            if [ -n "$KV_NAME" ] && [ -n "$RG_NAME" ]; then
              echo "Resolving Key Vault details via Azure CLI..."
              az account set --subscription "$ARM_SUBSCRIPTION_ID"
              az login --service-principal -u "$ARM_CLIENT_ID" -p "$ARM_CLIENT_SECRET" --tenant "$ARM_TENANT_ID" --output none || true
              KV_ID=$(az keyvault show -n "$KV_NAME" -g "$RG_NAME" --query id -o tsv || echo "")
              KV_URI=$(az keyvault show -n "$KV_NAME" -g "$RG_NAME" --query properties.vaultUri -o tsv || echo "")
            fi

            # Create temporary tfvars file if we have minimum required values
            if [ -n "$ADB_ID" ] && [ -n "$ADB_HOST" ]; then
              echo "adb_databricks_hosturl = \"$ADB_HOST\"" > destroy-temp.auto.tfvars
              echo "adb_databricks_id = \"$ADB_ID\"" >> destroy-temp.auto.tfvars
              echo "key_vault_id = \"$KV_ID\"" >> destroy-temp.auto.tfvars
              echo "key_vault_uri = \"$KV_URI\"" >> destroy-temp.auto.tfvars
              echo "Created destroy-temp.auto.tfvars:"
              cat destroy-temp.auto.tfvars
            else
              echo "ERROR: Missing required values (adb id/host). Destroy may fail."
            fi
        env:
          ARM_CLIENT_ID: $(ARM_CLIENT_ID)
          ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
          ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(ARM_TENANT_ID)
        continueOnError: true

      - task: Bash@3
        displayName: "Eirctl: [DESTROY] Plan ${{ parameters.stage_name }}"
        inputs:
          targetType: inline
          script: |
            eirctl infra:destroy:plan
        env:
          ARM_CLIENT_ID: $(ARM_CLIENT_ID)
          ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
          ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(ARM_TENANT_ID)
          TF_VAR_name_company: $(company)
          TF_VAR_name_project: $(project)
          TF_VAR_ado_org_url: $(ado_org_url)
          TF_VAR_ado_project_id: $(ado_project_id)

      - task: Bash@3
        displayName: "Eirctl: [DESTROY] Apply ${{ parameters.stage_name }}"
        inputs:
          targetType: inline
          script: |
            eirctl infra:destroy:apply
        env:
          ARM_CLIENT_ID: $(ARM_CLIENT_ID)
          ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
          ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(ARM_TENANT_ID)

  - ${{ if eq(parameters.deploy, true) }}:
      - task: Bash@3
        displayName: "Eirctl: Plan ${{ parameters.stage_name }}"
        inputs:
          targetType: inline
          script: |
            eirctl -d infra:plan
        env:
          ARM_CLIENT_ID: $(ARM_CLIENT_ID)
          ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
          ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(ARM_TENANT_ID)
          TF_VAR_name_company: $(company)
          TF_VAR_name_project: $(project)
          TF_VAR_ado_org_url: $(ado_org_url)
          TF_VAR_ado_project_id: $(ado_project_id)

      - task: Bash@3
        displayName: "Eirctl: Apply ${{ parameters.stage_name }}"
        inputs:
          targetType: inline
          script: |
            export USER_ID=`id -u`
            export USER_GROUP_ID=`id -g`
            eirctl infra:apply
        env:
          ARM_CLIENT_ID: $(ARM_CLIENT_ID)
          ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
          ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
          ARM_TENANT_ID: $(ARM_TENANT_ID)

      - task: CopyFiles@2
        displayName: Copy stage output files to staging area
        inputs:
          flattenFolders: true
          contents: $(Build.SourcesDirectory)/outputs/terraform/*${{ parameters.stage_name }}*
          targetFolder: $(Build.ArtifactStagingDirectory)/${{ parameters.stage_name }}

      - task: Bash@3
        displayName: "Ensure ${{ parameters.stage_name }} artifact directory exists"
        inputs:
          targetType: inline
          script: |
            mkdir -p $(Build.ArtifactStagingDirectory)/${{ parameters.stage_name }}
            echo "Staging directory prepared: $(Build.ArtifactStagingDirectory)/${{ parameters.stage_name }}"

      - task: PublishPipelineArtifact@1
        displayName: Upload Generated Files
        inputs:
          targetPath: $(Build.ArtifactStagingDirectory)/${{ parameters.stage_name }}
          artifact: ${{ parameters.stage_name }}

  - task: Bash@3
    displayName: "Docker: Save image to cache"
    condition: and(succeeded(), ne(variables.DOCKER_CACHE_RESTORED, 'true'))
    inputs:
      targetType: inline
      script: |
        mkdir -p $(Pipeline.Workspace)/.docker-cache
        echo "Saving Docker image to cache..."
        IMAGE=""
        for CAND in \
          ghcr.io/ensono/eir-infrastructure:$(EirctlVersion) \
          ensono/eir-infrastructure:$(EirctlVersion) \
          ghcr.io/ensono/eir-infrastructure:latest \
          ensono/eir-infrastructure:latest; do
          if docker image inspect "$CAND" >/dev/null 2>&1; then
            IMAGE="$CAND"
            break
          fi
        done
        if [ -n "$IMAGE" ]; then
          echo "Caching image: $IMAGE"
          docker save "$IMAGE" -o $(Pipeline.Workspace)/.docker-cache/eir-infrastructure.tar
        else
          echo "WARNING: No eir-infrastructure image found to cache"
        fi
        echo "Docker image cached successfully"
